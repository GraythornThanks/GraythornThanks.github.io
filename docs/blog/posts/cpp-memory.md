---
date: 2025-06-11
draft: true
categories:
  - C++
tags:
  - C++
authors:
  - admin
---

# C++ 生命周期与智能指针

<!-- more -->

## 生存期

TODO

## 存储周期

### 1. 自动存储周期

这种变量在进入其作用域时被创建，在离开其作用域时被销毁。

```cpp
void func() {
    int a = 1; // a 是自动存储周期
    // 直接定义在{}内，俗称"栈上"或"局部变量"
}
```

### 2. 动态存储周期

这种变量在运行时通过new创建，在运行时通过delete销毁。

```cpp
void func() {
    Class *p = new Class;  // *p 是动态存储周期
    delete p;              // 释放动态分配的内存
}
```

### 3. 静态存储周期

这种变量在程序的整个生命周期中都存在。

```cpp
namespace ns { // a b c 是静态存储周期
  class a;
  static class b;
  inline class c;
} // 构造时机：程序启动时/DLL首次加载时；析构时机：程序结束时

int a = 1; // a 是静态存储周期，可以认为全局名字空间是一个特殊的名字空间

struct Other {
    static Class s;
};
Class Other::s; // 定义在类内的静态成员 s 是静态存储周期
```

### 总结

- 自动存储周期：栈上局部变量，自动析构
- 动态存储周期：通过new创建的堆上变量，需要手动delete析构
- 静态存储周期：全局名字空间，程序结束时析构

**动态存储周期的变量需要我们自己管理！**

!!! question "如何更好地管理动态存储周期的变量？"
    RAII: Resource Acquisition Is Initialization <br>
    通过类似栈上的变量自动析构的方式来管理动态存储周期的变量

!!! question "如果直接用delete手动管理？"
    无法保证delete的时机与顺序<br>
    一旦出现多个分支离开作用域，就无法保证delete的顺序

## RAII

RAII (Resource Acquisition Is Initialization) 即：资源获取即初始化

> “资源管理应当与对象的生命周期绑定。这是 C++ 区别于 C 的关键特性之一。” <br>
> —— Bjarne Stroustrup, 《The C++ Programming Language》

**核心思想**

1. 资源绑定对象

    - 将资源（内存、文件句柄、网络连接、锁等）的生命周期与对象的生命周期绑定。
    - 资源在构造函数中获取，在析构函数中释放。

2. 自动管理

    - 当对象离开作用域时（如函数结束、代码块退出），析构函数自动调用，确保资源释放。
    - 即使发生异常，栈回退（stack unwinding）机制也能保证析构函数被执行，避免资源泄漏。



### 实现 RAII 类

TODO

### 三/五/零法则

如果类*管理资源*，且该资源的句柄是非类类型的对象，类自动生成的析构函数不执行任何操作，并且复制构造函数和复制赋值运算符执行浅拷贝，这可能导致资源泄漏或双重释放

```cpp
// double free
```
三法则：如果一个类需要用户定义的析构函数、用户定义的复制构造函数或用户定义的复制赋值运算符，那么它应该定义所有三个

五法则：C++11引入移动语义，自此三法则变成五法则。由于用户定义的（包括声明为 = default 或 = delete）析构函数、复制构造函数或复制赋值运算符会阻止隐式定义移动构造函数和移动赋值运算符，因此任何需要移动语义的类都必须声明所有五个特殊成员函数

零法则：具有自定义析构函数、复制/移动构造函数或复制/移动赋值运算符的类应专门处理所有权（遵循单一职责原则！）。其他类不应具有自定义析构函数、复制/移动构造函数或复制/移动赋值运算符。

根据三/五/零法则：

- 需要自定义析构/拷贝/移动操作的类：它很可能正在直接管理资源（内存、句柄）
    - 这样的类必须专门处理所有权问题
    - 清晰地定义所有权语义
    - 正确实现“五法则”：定义了其中一个特殊函数（析构、拷贝构造、拷贝赋值、移动构造、移动赋值），通常需要考虑定义或显式禁止所有五个，确保资源在各种操作（构造、拷贝、移动、赋值、析构）下都能被正确、安全地管理（无泄漏、无悬空、异常安全）

- 不需要自定义析构/拷贝/移动操作的类：如果一个类不需要自定义上面提到的任何一个特殊成员函数，那么它不应该拥有它们
    - 依赖编译器实现：平凡实现或逐成员拷贝/移动
    - 避免影响优化：手动定义一个空的析构函数~MyClass() {}，即使什么也不做，也会改变类的性质，**在不需要特殊成员函数时，请 =default 或者直接 =delete**
    - 保持简单：成员要么是值语义，要么其资源已经由自身完美处理
    - 委托资源管理：如果需要持有资源，它应该通过成员变量使用已经实现了完善资源管理的类型（如std::unique_ptr管理动态内存，std::shared_ptr管理共享内存，std::vector管理动态数组，std::string管理字符串，std::fstream管理文件等）
  

## 参考

- [三大存储周期](https://cppreference.cn/w/cpp/language/storage_duration)
- [RAII](https://cppreference.cn/w/cpp/language/raii)
- [三/五/零法则](https://cppreference.cn/w/cpp/language/rule_of_three)
- [《【C++11】自己封装RAII类，有哪些坑点？带你了解移动语义的真相》- 双笙子佯谬](https://www.bilibili.com/video/BV11Z421u7xZ/?spm_id_from=333.1387.upload.video_card.click&vd_source=ca7901515a908c312c09d48b9b3afbee)